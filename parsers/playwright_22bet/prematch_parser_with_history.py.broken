#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
22bet PREMATCH Parser v4.0 - WITH FULL HISTORY TRACKING
–û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ —Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞–º–∏ Alg1 –∏ Alg2
"""

import asyncio
import pymysql
from datetime import datetime, timedelta
from playwright.async_api import async_playwright
import time

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
DB_CONFIG = {
    'host': 'localhost',
    'user': 'root',
    'password': 'ryban8991!',
    'database': 'inforadar',
    'charset': 'utf8mb4'
}

PROXY_CONFIG = {
    'server': 'http://46.182.207.241:12323',
    'username': '14ab0fcf235c2',
    'password': '380da05609'
}

UPDATE_INTERVAL = 45  # —Å–µ–∫—É–Ω–¥—ã
HOURS_AHEAD = 12

# –ü–æ—Ä–æ–≥–∏ –¥–ª—è –∞–Ω–æ–º–∞–ª–∏–π
SHARP_DROP_THRESHOLD = -5.0
SHARP_RISE_THRESHOLD = 5.0
CRITICAL_CHANGE = 10.0

print("=" * 70)
print("22bet PREMATCH Parser v4.0 - FULL HISTORY TRACKING")
print("=" * 70)
print(f"Update: {UPDATE_INTERVAL}s | Window: {HOURS_AHEAD}h")
print(f"Proxy: {PROXY_CONFIG['server']}")
print("=" * 70)


class OddsHistoryTracker:
    """–ö–ª–∞—Å—Å –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤"""
    
    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor(pymysql.cursors.DictCursor)
        self.previous_odds = {}
    
    def calculate_indicators(self, old_value, new_value, time_diff_seconds=45):
        """–†–∞—Å—á–µ—Ç Alg1 –∏ Alg2"""
        if old_value is None or new_value is None or old_value == 0:
            return 0.0, 0.0
        
        alg1 = new_value - old_value
        change_pct = ((new_value - old_value) / old_value) * 100
        speed_factor = max(1.0, 60.0 / time_diff_seconds)
        alg2 = abs(change_pct) * speed_factor * 0.01
        
        return round(alg1, 3), round(alg2, 3)
    
    def get_previous_odds(self, eventname, markettype):
        """–ü–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã"""
        key = f"{eventname}_{markettype}"
        
        if key in self.previous_odds:
            return self.previous_odds[key]
        
        query = """
        SELECT odd1, oddx, odd2, handicap_home, handicap_away, 
               total_over, total_under, timestamp
        FROM odds_history
        WHERE eventname = %s AND markettype = %s AND bookmaker = '22bet'
        ORDER BY timestamp DESC LIMIT 1
        """
        self.cursor.execute(query, (eventname, markettype))
        result = self.cursor.fetchone()
        
        if result:
            self.previous_odds[key] = result
            return result
        return None
    
    def save_odds_snapshot(self, eventname, eventid, markettype, odds_data, matchtime):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–Ω–∏–º–æ–∫ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ —Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞–º–∏"""
        try:
            prev = self.get_previous_odds(eventname, markettype)
            
            alg1_max, alg2_max = 0.0, 0.0
            changes = []
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ 1X2
            if markettype == '1X2' and 'odd1' in odds_data:
                if prev:
                    for key in ['odd1', 'oddx', 'odd2']:
                        if key in odds_data and prev.get(key):
                            alg1, alg2 = self.calculate_indicators(
                                float(prev[key]), 
                                float(odds_data[key])
                            )
                            if abs(alg2) > abs(alg2_max):
                                alg1_max, alg2_max = alg1, alg2
                            
                            change_pct = ((float(odds_data[key]) - float(prev[key])) / float(prev[key])) * 100
                            changes.append({
                                'outcome': key.replace('odd', '').replace('1', '1').replace('x', 'X'),
                                'before': float(prev[key]),
                                'after': float(odds_data[key]),
                                'change_pct': change_pct,
                                'alg2': alg2
                            })
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ Handicap
            elif markettype == 'Handicap' and 'handicap_home' in odds_data:
                if prev:
                    for key in ['handicap_home', 'handicap_away']:
                        if key in odds_data and prev.get(key):
                            alg1, alg2 = self.calculate_indicators(
                                float(prev[key]),
                                float(odds_data[key])
                            )
                            if abs(alg2) > abs(alg2_max):
                                alg1_max, alg2_max = alg1, alg2
                            
                            change_pct = ((float(odds_data[key]) - float(prev[key])) / float(prev[key])) * 100
                            changes.append({
                                'outcome': 'Home' if 'home' in key else 'Away',
                                'before': float(prev[key]),
                                'after': float(odds_data[key]),
                                'change_pct': change_pct,
                                'alg2': alg2
                            })
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ Total
            elif markettype == 'Total' and 'total_over' in odds_data:
                if prev:
                    for key in ['total_over', 'total_under']:
                        if key in odds_data and prev.get(key):
                            alg1, alg2 = self.calculate_indicators(
                                float(prev[key]),
                                float(odds_data[key])
                            )
                            if abs(alg2) > abs(alg2_max):
                                alg1_max, alg2_max = alg1, alg2
                            
                            change_pct = ((float(odds_data[key]) - float(prev[key])) / float(prev[key])) * 100
                            changes.append({
                                'outcome': 'Over' if 'over' in key else 'Under',
                                'before': float(prev[key]),
                                'after': float(odds_data[key]),
                                'change_pct': change_pct,
                                'alg2': alg2
                            })
            
            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î
            sql = """
            INSERT INTO odds_history 
            (eventid, eventname, bookmaker, markettype, 
             odd1, oddx, odd2, 
             handicap_value, handicap_home, handicap_away,
             total_value, total_over, total_under,
             alg1, alg2, matchtime, status)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            self.cursor.execute(sql, (
                eventid or eventname[:50],
                eventname,
                '22bet',
                markettype,
                odds_data.get('odd1'),
                odds_data.get('oddx'),
                odds_data.get('odd2'),
                odds_data.get('handicap_value'),
                odds_data.get('handicap_home'),
                odds_data.get('handicap_away'),
                odds_data.get('total_value'),
                odds_data.get('total_over'),
                odds_data.get('total_under'),
                alg1_max,
                alg2_max,
                matchtime,
                'prematch'
            ))
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞
            key = f"{eventname}_{markettype}"
            self.previous_odds[key] = {**odds_data, 'timestamp': datetime.now()}
            
            # –î–µ—Ç–µ–∫—Ü–∏—è –∞–Ω–æ–º–∞–ª–∏–π
            for change in changes:
                if abs(change['change_pct']) >= abs(SHARP_DROP_THRESHOLD):
                    severity = self.classify_severity(change['change_pct'])
                    anomaly_type = 'sharp_drop' if change['change_pct'] < 0 else 'sharp_rise'
                    
                    self.save_anomaly(
                        eventname, eventid, markettype, change['outcome'],
                        change['before'], change['after'], change['change_pct'],
                        change['alg2'], severity, anomaly_type, matchtime
                    )
                    
                    emoji = "üîª" if change['change_pct'] < 0 else "üî∫"
                    print(f"{emoji} ANOMALY: {eventname[:40]} | {markettype}-{change['outcome']} | "
                          f"{change['change_pct']:+.2f}% | Alg2={change['alg2']:.3f} | {severity.upper()}")
            
            self.conn.commit()
            
        except Exception as e:
            print(f"‚ùå Save history error: {e}")
            self.conn.rollback()
    
    def classify_severity(self, change_pct):
        """–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —Å–µ—Ä—å–µ–∑–Ω–æ—Å—Ç–∏"""
        abs_change = abs(change_pct)
        if abs_change >= CRITICAL_CHANGE:
            return 'critical'
        elif abs_change >= 7:
            return 'high'
        elif abs_change >= 5:
            return 'medium'
        else:
            return 'low'
    
    def save_anomaly(self, eventname, eventid, markettype, outcome, 
                     odds_before, odds_after, change_pct, change_speed,
                     severity, anomaly_type, matchtime):
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∞–Ω–æ–º–∞–ª–∏—é"""
        sql = """
        INSERT INTO odds_anomalies_v2 
        (eventid, eventname, bookmaker, markettype, outcome, 
         odds_before, odds_after, change_pct, change_speed,
         severity, anomaly_type, matchtime)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        try:
            self.cursor.execute(sql, (
                eventid or eventname[:50],
                eventname,
                '22bet',
                markettype,
                outcome,
                odds_before,
                odds_after,
                change_pct,
                change_speed,
                severity,
                anomaly_type,
                matchtime
            ))
        except Exception as e:
            print(f"‚ùå Anomaly save error: {e}")


class PrematchParser:
    """–ü–∞—Ä—Å–µ—Ä prematch —Å –∏—Å—Ç–æ—Ä–∏–µ–π"""
    
    def __init__(self):
        self.conn = None
        self.cursor = None
        self.tracker = None
        self.seen_matches = set()
    
    def connect_db(self):
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MySQL"""
        self.conn = pymysql.connect(**DB_CONFIG)
        self.cursor = self.conn.cursor()
        self.tracker = OddsHistoryTracker(self.conn)
        print("‚úÖ MySQL connected")
    
    def clear_old_data(self):
        """–û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
        now = datetime.now()
        cutoff = now + timedelta(hours=HOURS_AHEAD)
        stale_time = now - timedelta(minutes=5)
        
        self.cursor.execute("""
            DELETE FROM odds22bet 
            WHERE bookmaker='22bet' AND matchtime < %s
        """, (now,))
        deleted_started = self.cursor.rowcount
        
        self.cursor.execute("""
            DELETE FROM odds22bet 
            WHERE bookmaker='22bet' AND matchtime > %s
        """, (cutoff,))
        deleted_outside = self.cursor.rowcount
        
        self.cursor.execute("""
            DELETE FROM odds22bet 
            WHERE bookmaker='22bet' AND updatedat < %s
        """, (stale_time,))
        deleted_stale = self.cursor.rowcount
        
        self.conn.commit()
        print(f"üóëÔ∏è  Deleted: {deleted_started} started, {deleted_outside} outside, {deleted_stale} stale")
    
    def parse_time(self, time_str: str):
        """–ü–∞—Ä—Å–∏–Ω–≥ –≤—Ä–µ–º–µ–Ω–∏"""
        try:
            parts = time_str.strip().split()
            if len(parts) != 2:
                return None
            
            date_part, time_part = parts[0], parts[1]
            
            if '.' in date_part:
                day, month = date_part.split('.')
            else:
                day, month = date_part.split('/')
            
            hour, minute = time_part.split(':')
            
            now = datetime.now()
            year = now.year
            dt = datetime(year, int(month), int(day), int(hour), int(minute))
            
            if dt < now:
                dt = datetime(year + 1, int(month), int(day), int(hour), int(minute))
            
            return dt
        except Exception:
            return None
    
    async def parse_prematch(self, page):
        """–û—Å–Ω–æ–≤–Ω–æ–π –ø–∞—Ä—Å–∏–Ω–≥"""
        try:
            print("üì° Loading football page...")
            await page.goto('https://22betluck.com/ru/line/football', timeout=90000)
            await page.wait_for_timeout(8000)
            
            current_url = page.url
            print(f"‚úÖ URL: {current_url}")
            
            if 'football' not in current_url.lower():
                print(f"‚ùå WRONG PAGE!")
                return 0
        
        except Exception as e:
            print(f"‚ùå Page load error: {e}")
            return 0
        
        # –ü—Ä–æ–∫—Ä—É—Ç–∫–∞
        print("üìú Scrolling...")
        previous_height = 0
        scroll_iterations = 0
        max_iterations = 200
        
        while scroll_iterations < max_iterations:
            await page.evaluate('window.scrollTo(0, document.body.scrollHeight)')
            await page.wait_for_timeout(500)
            
            current_height = await page.evaluate('document.body.scrollHeight')
            
            if current_height == previous_height:
                print(f"‚úÖ Scrolled {scroll_iterations} times")
                break
            
            previous_height = current_height
            scroll_iterations += 1
            
            if scroll_iterations % 20 == 0:
                print(f"   ... {scroll_iterations}")
            if scroll_iterations % 20 == 0:
                print(f"   ... {scroll_iterations}")
        
        # –ü–∞—Ä—Å–∏–Ω–≥ –º–∞—Ç—á–µ–π
        print("üîç Parsing matches...")
        
        try:
            html_content = await page.content()
            
            # –°–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è 22bet
            match_blocks = await page.query_selector_all('.c-events__item, .event-block')
            print(f"üìä Found {len(match_blocks)} match blocks")
            
            saved_count = 0
            
            for idx, match in enumerate(match_blocks):
                try:
                    # –ù–∞–∑–≤–∞–Ω–∏–µ –º–∞—Ç—á–∞
                    name_elem = await match.query_selector('.c-events__name, .event-name')
                    if not name_elem:
                        continue
                    
                    event_name = (await name_elem.text_content()).strip()
                    
                    # –í—Ä–µ–º—è –º–∞—Ç—á–∞
                    time_elem = await match.query_selector('.c-events__time, .event-time')
                    if not time_elem:
                        continue
                    
                    time_str = (await time_elem.text_content()).strip()
                    match_time = self.parse_time(time_str)
                    
                    if not match_time:
                        continue
                    
                    # –õ–∏–≥–∞
                    league_elem = await match.query_selector('.c-events__league, .league-name')
                    league = (await league_elem.text_content()).strip() if league_elem else "Unknown"
                    
                    # –ü–∞—Ä—Å–∏–Ω–≥ 1X2
                    odds_buttons = await match.query_selector_all('.c-bets__bet, .coef')
                    
                    if len(odds_buttons) >= 3:
                        try:
                            odd1 = float((await odds_buttons[0].text_content()).strip())
                            oddx = float((await odds_buttons[1].text_content()).strip())
                            odd2 = float((await odds_buttons[2].text_content()).strip())
                            
                            odds_1x2 = {
                                'odd1': odd1,
                                'oddx': oddx,
                                'odd2': odd2
                            }
                            
                            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é
                            self.tracker.save_odds_snapshot(
                                eventname=event_name,
                                eventid=None,
                                markettype='1X2',
                                odds_data=odds_1x2,
                                matchtime=match_time
                            )
                            
                            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ odds22bet
                            self.save_to_odds22bet(event_name, league, odds_1x2, match_time)
                            
                            saved_count += 1
                            
                        except (ValueError, IndexError) as e:
                            pass
                    
                except Exception as e:
                    continue
            
            self.conn.commit()
            print(f"‚úÖ Saved {saved_count} matches")
            return saved_count
            
        except Exception as e:
            print(f"‚ùå Parsing error: {e}")
            return 0
    
    def save_to_odds22bet(self, eventname, league, odds_1x2, matchtime):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ odds22bet –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏"""
        try:
            sql = """
            INSERT INTO odds22bet 
            (eventname, league, sport, markettype, odd1, oddx, odd2, matchtime, 
             bookmaker, status, updatedat)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW())
            ON DUPLICATE KEY UPDATE
            odd1 = VALUES(odd1),
            oddx = VALUES(oddx),
            odd2 = VALUES(odd2),
            updatedat = NOW()
            """
            
            self.cursor.execute(sql, (
                eventname,
                league,
                'Football',
                '1X2',
                odds_1x2.get('odd1'),
                odds_1x2.get('oddx'),
                odds_1x2.get('odd2'),
                matchtime,
                '22bet',
                'active'
            ))
        except Exception as e:
            print(f"‚ùå Save to odds22bet error: {e}")
    
    def close(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π"""
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()
        print("üîå DB disconnected")


async def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    parser = PrematchParser()
    parser.connect_db()
    
    async with async_playwright() as p:
        print("üåê Launching browser...")
        
        browser = await p.chromium.launch(
            headless=True,
            proxy=PROXY_CONFIG
        )
        
        context = await browser.new_context(
            viewport={'width': 1920, 'height': 1080},
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        )
        
        page = await context.new_page()
        
        try:
            iteration = 0
            while True:
                iteration += 1
                print(f"\n{'='*70}")
                print(f"üîÑ ITERATION {iteration} | {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                print(f"{'='*70}")
                
                parser.clear_old_data()
                
                saved = await parser.parse_prematch(page)
                
                print(f"\n‚úÖ Iteration {iteration} completed: {saved} matches")
                print(f"‚è≥ Waiting {UPDATE_INTERVAL}s...")
                
                await asyncio.sleep(UPDATE_INTERVAL)
        
        except KeyboardInterrupt:
            print("\n\n‚ö†Ô∏è  CTRL+C detected - stopping...")
        
        except Exception as e:
            print(f"\n‚ùå Fatal error: {e}")
        
        finally:
            await browser.close()
            parser.close()
            print("\n‚úÖ Parser stopped")


if __name__ == '__main__':
    asyncio.run(main())
